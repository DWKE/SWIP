var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"PID_controller_codegen/Controller","ref":false,"files":[{"name":"Controller_sf.c","type":"source","group":"model","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Controller_sf.c\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Controller_sf.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Controller_sf_private.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\nextern void *Controller_malloc(SimStruct *S);\r\n\r\n#endif\r\n\r\n#ifndef __RTW_UTFREE__\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\nextern void * utMalloc(size_t);\r\nextern void utFree(void *);\r\n\r\n#endif\r\n#endif                                 /* #ifndef __RTW_UTFREE__ */\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\r\n  \"memory allocation error in generated S-Function\";\r\n\r\n/* System initialize for root system: '<Root>' */\r\n#define MDL_INITIALIZE_CONDITIONS\r\n\r\nstatic void mdlInitializeConditions(SimStruct *S)\r\n{\r\n  if (ssIsFirstInitCond(S)) {\r\n    /* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' */\r\n    ((real_T *)ssGetDWork(S, 0))[0] = 0.0;\r\n\r\n    /* InitializeConditions for UnitDelay: '<S2>/UD' */\r\n    ((real_T *)ssGetDWork(S, 1))[0] = 0.0;\r\n  } else {\r\n    /* InitializeConditions for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' */\r\n    ((real_T *)ssGetDWork(S, 0))[0] = 0.0;\r\n\r\n    /* InitializeConditions for UnitDelay: '<S2>/UD' */\r\n    ((real_T *)ssGetDWork(S, 1))[0] = 0.0;\r\n  }\r\n}\r\n\r\n/* Start for root system: '<Root>' */\r\n#define MDL_START\r\n\r\nstatic void mdlStart(SimStruct *S)\r\n{\r\n  /* instance underlying S-Function data */\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  /* non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n#endif\r\n\r\n  Controller_malloc(S);\r\n  if (ssGetErrorStatus(S) != (NULL) ) {\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  {\r\n  }\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  B_Controller_T *_rtB;\r\n  _rtB = ((B_Controller_T *) ssGetLocalBlockIO(S));\r\n\r\n  /* SampleTimeMath: '<S2>/TSamp'\r\n   *\r\n   * About '<S2>/TSamp':\r\n   *  y = u * K where K = 1 / ( w * Ts )\r\n   */\r\n  _rtB->TSamp = *((const real_T **)ssGetInputPortSignalPtrs(S, 0))[0] * 1000.0;\r\n\r\n  /* Outport: '<Root>/Out1' incorporates:\r\n   *  DiscreteIntegrator: '<S1>/Discrete-Time Integrator'\r\n   *  Gain: '<S1>/Gain'\r\n   *  Gain: '<S1>/Gain1'\r\n   *  Gain: '<S1>/Gain2'\r\n   *  Sum: '<S1>/Sum1'\r\n   *  Sum: '<S2>/Diff'\r\n   *  UnitDelay: '<S2>/UD'\r\n   */\r\n  ((real_T *)ssGetOutputPortSignal(S, 0))[0] = (100.0 * *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 0))[0] + 100.0 * ((real_T *)ssGetDWork(S, 0))[0])\r\n    + (_rtB->TSamp - ((real_T *)ssGetDWork(S, 1))[0]) * 5.0;\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\n#define MDL_UPDATE\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n  B_Controller_T *_rtB;\r\n  _rtB = ((B_Controller_T *) ssGetLocalBlockIO(S));\r\n\r\n  /* Update for DiscreteIntegrator: '<S1>/Discrete-Time Integrator' */\r\n  ((real_T *)ssGetDWork(S, 0))[0] = 0.001 * *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 0))[0] + ((real_T *)ssGetDWork(S, 0))[0];\r\n\r\n  /* Update for UnitDelay: '<S2>/UD' */\r\n  ((real_T *)ssGetDWork(S, 1))[0] = _rtB->TSamp;\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetUserData(S) != (NULL) ) {\r\n    rt_FREE(ssGetLocalBlockIO(S));\r\n  }\r\n\r\n  rt_FREE(ssGetUserData(S));\r\n\r\n#endif\r\n\r\n}\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#include \"Controller_mid.h\"\r\n#endif\r\n\r\n/* Function to initialize sizes. */\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSampleTimes(S, 1);           /* Number of sample times */\r\n  ssSetNumContStates(S, 0);            /* Number of continuous states */\r\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\r\n\r\n  /* Number of output ports */\r\n  if (!ssSetNumOutputPorts(S, 1))\r\n    return;\r\n\r\n  /* outport number: 0 */\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortSampleTime(S, 0, 0.001);\r\n  ssSetOutputPortOffsetTime(S, 0, 0.0);\r\n  ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* Number of input ports */\r\n  if (!ssSetNumInputPorts(S, 1))\r\n    return;\r\n\r\n  /* inport number: 0 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 0, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n    ssSetInputPortSampleTime(S, 0, 0.001);\r\n    ssSetInputPortOffsetTime(S, 0, 0.0);\r\n    ssSetInputPortOverWritable(S, 0, 0);\r\n    ssSetInputPortOptimOpts(S, 0, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\r\n\r\n  /* DWork */\r\n  if (!ssSetNumDWork(S, 2)) {\r\n    return;\r\n  }\r\n\r\n  /* '<S1>/Discrete-Time Integrator': DSTATE */\r\n  ssSetDWorkName(S, 0, \"DWORK0\");\r\n  ssSetDWorkWidth(S, 0, 1);\r\n  ssSetDWorkUsedAsDState(S, 0, 1);\r\n\r\n  /* '<S2>/UD': DSTATE */\r\n  ssSetDWorkName(S, 1, \"DWORK1\");\r\n  ssSetDWorkWidth(S, 1, 1);\r\n  ssSetDWorkUsedAsDState(S, 1, 1);\r\n\r\n  /* Tunable Parameters */\r\n  ssSetNumSFcnParams(S, 0);\r\n\r\n  /* Number of expected parameters */\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n    if (ssGetErrorStatus(S) != (NULL) ) {\r\n      return;\r\n    }\r\n  } else {\r\n    return;                /* Parameter mismatch will be reported by Simulink */\r\n  }\r\n\r\n#endif                                 /* MATLAB_MEX_FILE */\r\n\r\n  /* Options */\r\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE |\r\n                   SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED ));\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  {\r\n    ssSupportsMultipleExecInstances(S, true);\r\n    ssHasStateInsideForEachSS(S, false);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  /* task periods */\r\n  ssSetSampleTime(S, 0, 0.001);\r\n\r\n  /* task offsets */\r\n  ssSetOffsetTime(S, 0, 0.0);\r\n}\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"fixedpoint.c\"\r\n#include \"simulink.c\"\r\n#else\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME                Controller_sf\r\n#include \"cg_sfun.h\"\r\n#endif                                 /* defined(MATLAB_MEX_FILE) */\r\n"},{"name":"Controller_sf.h","type":"header","group":"model","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Controller_sf.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller_sf_h_\r\n#define RTW_HEADER_Controller_sf_h_\r\n#ifndef Controller_sf_COMMON_INCLUDES_\r\n#define Controller_sf_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#define S_FUNCTION_NAME                Controller_sf\r\n#define S_FUNCTION_LEVEL               2\r\n#ifndef RTW_GENERATED_S_FUNCTION\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if !defined(MATLAB_MEX_FILE)\r\n#include \"rt_matrx.h\"\r\n#endif\r\n\r\n#if !defined(RTW_SFUNCTION_DEFINES)\r\n#define RTW_SFUNCTION_DEFINES\r\n\r\ntypedef struct {\r\n  void *blockIO;\r\n  void *defaultParam;\r\n  void *nonContDerivSig;\r\n} LocalS;\r\n\r\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\r\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\r\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\r\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\r\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\r\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\r\n#endif\r\n#endif                                 /* Controller_sf_COMMON_INCLUDES_ */\r\n\r\n#include \"Controller_sf_types.h\"\r\n#include <string.h>\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <stddef.h>\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T TSamp;                        /* '<S2>/TSamp' */\r\n} B_Controller_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T *e;                           /* '<Root>/e' */\r\n} ExternalUPtrs_Controller_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T *Out1;                        /* '<Root>/Out1' */\r\n} ExtY_Controller_T;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S2>/Data Type Duplicate' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('PID_controller_codegen/Controller')    - opens subsystem PID_controller_codegen/Controller\r\n * hilite_system('PID_controller_codegen/Controller/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'PID_controller_codegen'\r\n * '<S1>'   : 'PID_controller_codegen/Controller'\r\n * '<S2>'   : 'PID_controller_codegen/Controller/Discrete Derivative'\r\n */\r\n#endif                                 /* RTW_HEADER_Controller_sf_h_ */\r\n"},{"name":"Controller_sf_private.h","type":"header","group":"model","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Controller_sf_private.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller_sf_private_h_\r\n#define RTW_HEADER_Controller_sf_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"Controller_sf_types.h\"\r\n#if !defined(ss_VALIDATE_MEMORY)\r\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_Controller_sf_private_h_ */\r\n"},{"name":"Controller_sf_types.h","type":"header","group":"model","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Controller_sf_types.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Controller_sf_types_h_\r\n#define RTW_HEADER_Controller_sf_types_h_\r\n#endif                                 /* RTW_HEADER_Controller_sf_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetInf.h\r\n    *\r\n            * Trial License - for use to evaluate programs for possible purchase as\r\n* an end-user only.\r\n        *\r\n    * Code generation for model \"Controller_sf\".\r\n    *\r\n    * Model version              : 1.1\r\n    * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n        * C source code generated on : Wed Aug 30 15:30:27 2023\r\n * \r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetInf_h_\r\n    #define RTW_HEADER_rtGetInf_h_\r\n\r\n\r\n\r\n    \r\n#include \"rtwtypes.h\"\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetInf(void);\r\n            extern real32_T rtGetInfF(void);\r\n            extern real_T rtGetMinusInf(void);\r\n            extern real32_T rtGetMinusInfF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetNaN.h\r\n    *\r\n            * Trial License - for use to evaluate programs for possible purchase as\r\n* an end-user only.\r\n        *\r\n    * Code generation for model \"Controller_sf\".\r\n    *\r\n    * Model version              : 1.1\r\n    * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n        * C source code generated on : Wed Aug 30 15:30:27 2023\r\n * \r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetNaN_h_\r\n    #define RTW_HEADER_rtGetNaN_h_\r\n\r\n\r\n\r\n    \r\n#include \"rtwtypes.h\"\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetNaN(void);\r\n            extern real32_T rtGetNaNF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_defines.h\r\n    *\r\n            * Trial License - for use to evaluate programs for possible purchase as\r\n* an end-user only.\r\n        *\r\n    * Code generation for model \"Controller_sf\".\r\n    *\r\n    * Model version              : 1.1\r\n    * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n        * C source code generated on : Wed Aug 30 15:30:27 2023\r\n * \r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_defines_h_\r\n    #define RTW_HEADER_rt_defines_h_\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    /*===========*\r\n    * Constants *\r\n    *===========*/\r\n\r\n    #define RT_PI          3.14159265358979323846\r\n    #define RT_PIF         3.1415927F\r\n    #define RT_LN_10       2.30258509299404568402\r\n    #define RT_LN_10F      2.3025851F\r\n    #define RT_LOG10E      0.43429448190325182765\r\n    #define RT_LOG10EF     0.43429449F\r\n    #define RT_E           2.7182818284590452354\r\n    #define RT_EF          2.7182817F\r\n\r\n    /*\r\n    * UNUSED_PARAMETER(x)\r\n    *   Used to specify that a function parameter (argument) is required but not\r\n    *   accessed by the function body.\r\n    */\r\n    #ifndef UNUSED_PARAMETER\r\n    #if defined(__LCC__)\r\n    #define UNUSED_PARAMETER(x)  /* do nothing */\r\n    #else\r\n    /*\r\n    * This is the semi-ANSI standard way of indicating that an\r\n    * unused function parameter is required.\r\n    */\r\n    #define UNUSED_PARAMETER(x) (void) (x)\r\n    #endif\r\n    #endif\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.c\r\n    *\r\n            * Trial License - for use to evaluate programs for possible purchase as\r\n* an end-user only.\r\n        *\r\n    * Code generation for model \"Controller_sf\".\r\n    *\r\n    * Model version              : 1.1\r\n    * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n        * C source code generated on : Wed Aug 30 15:30:27 2023\r\n * \r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n\r\n\r\n    \r\n#include \"rtGetNaN.h\"\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n#include <stddef.h>\r\n\r\n#include \"rtwtypes.h\"\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        #define NumBitsPerChar  8U\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n                real_T rtInf;\r\n\r\n\r\n                real_T rtMinusInf;\r\n\r\n\r\n                real_T rtNaN;\r\n\r\n\r\n                real32_T rtInfF;\r\n\r\n\r\n                real32_T rtMinusInfF;\r\n\r\n\r\n                real32_T rtNaNF;\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    /* \r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\n\r\n         void rt_InitInfAndNaN(size_t realSize) {\r\n\r\n        (void) (realSize);\r\n        rtNaN = rtGetNaN();\r\n        rtNaNF = rtGetNaNF();\r\n        rtInf = rtGetInf();\r\n        rtInfF = rtGetInfF();\r\n        rtMinusInf = rtGetMinusInf();\r\n        rtMinusInfF = rtGetMinusInfF();\r\n    }\r\n    \r\n    /* Test if value is infinite */\r\n         boolean_T rtIsInf(real_T value) {\r\n        return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n    }\r\n    \r\n    /* Test if single-precision value is infinite */\r\n         boolean_T rtIsInfF(real32_T value) {\r\n        return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n    }\r\n    \r\n    /* Test if value is not a number */\r\n         boolean_T rtIsNaN(real_T value) {\r\n        boolean_T result = (boolean_T) 0;\r\n        size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n\r\n        if (bitsPerReal == 32U) {\r\n            result = rtIsNaNF((real32_T)value);\r\n        } else {\r\n                    \r\n    union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n    } tmpVal;\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n    ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n    (tmpVal.bitVal.words.wordL != 0) ));\r\n    \r\n\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /* Test if single-precision value is not a number */\r\n         boolean_T rtIsNaNF(real32_T value) {\r\n        IEEESingle tmp;\r\n        tmp.wordL.wordLreal = value;\r\n        return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n        (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n    }\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.h\r\n    *\r\n            * Trial License - for use to evaluate programs for possible purchase as\r\n* an end-user only.\r\n        *\r\n    * Code generation for model \"Controller_sf\".\r\n    *\r\n    * Model version              : 1.1\r\n    * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n        * C source code generated on : Wed Aug 30 15:30:27 2023\r\n * \r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_nonfinite_h_\r\n    #define RTW_HEADER_rt_nonfinite_h_\r\n\r\n\r\n\r\n    \r\n#include <stddef.h>\r\n\r\n#include \"rtwtypes.h\"\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        #define NOT_USING_NONFINITE_LITERALS 1\r\n\r\n    \r\n                extern real_T rtInf;\r\n\r\n\r\n                extern real_T rtMinusInf;\r\n\r\n\r\n                extern real_T rtNaN;\r\n\r\n\r\n                extern real32_T rtInfF;\r\n\r\n\r\n                extern real32_T rtMinusInfF;\r\n\r\n\r\n                extern real32_T rtNaNF;\r\n\r\n\r\n\r\n        extern void rt_InitInfAndNaN(size_t realSize);\r\n            extern boolean_T rtIsInf(real_T value);\r\n            extern boolean_T rtIsInfF(real32_T value);\r\n            extern boolean_T rtIsNaN(real_T value);\r\n            extern boolean_T rtIsNaNF(real32_T value);\r\n    \r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordH;\r\n        uint32_T wordL;\r\n    } words;\r\n    } BigEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordL;\r\n        uint32_T wordH;\r\n    } words;\r\n    } LittleEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    union {\r\n        real32_T wordLreal;\r\n        uint32_T wordLuint;\r\n    } wordL;\r\n    } IEEESingle;\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"Controller_mid.h","type":"header","group":"interface","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Controller_mid.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n * SOURCES: Controller_sf.c\r\n */\r\n\r\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\r\n\r\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\r\n{\r\n  _ssSetNumInputPorts(S,nInputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\r\n{\r\n  _ssSetNumOutputPorts(S,nOutputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\r\n{\r\n  static char msg[256];\r\n  if (strlen(ssGetModelName(S)) < 128) {\r\n    sprintf(msg,\r\n            \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\r\n            ssGetModelName(S));\r\n  } else {\r\n    sprintf(msg,\r\n            \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\r\n  }\r\n\r\n  ssSetErrorStatus(S, msg);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\n#endif\r\n\r\n/* Instance data for model: Controller */\r\nvoid *Controller_malloc(SimStruct *rts)\r\n{\r\n  /* Local SimStruct for the generated S-Function */\r\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\r\n  ss_VALIDATE_MEMORY(rts,lS);\r\n  (void) memset((char *) lS, 0,\r\n                sizeof(LocalS));\r\n  ssSetUserData(rts, lS);\r\n\r\n  /* block I/O */\r\n  {\r\n    void *b = malloc(sizeof(B_Controller_T));\r\n    ss_VALIDATE_MEMORY(rts,b);\r\n    ssSetLocalBlockIO(rts, b);\r\n    (void) memset(b, 0,\r\n                  sizeof(B_Controller_T));\r\n  }\r\n\r\n  /* model checksums */\r\n  ssSetChecksumVal(rts, 0, 763650684U);\r\n  ssSetChecksumVal(rts, 1, 2512694527U);\r\n  ssSetChecksumVal(rts, 2, 3947079430U);\r\n  ssSetChecksumVal(rts, 3, 2370651937U);\r\n  return (NULL);\r\n}\r\n"},{"name":"Controller_sid.h","type":"header","group":"interface","path":"C:\\Users\\user\\Desktop\\lke\\4. Matlab + Simulink + Stateflow\\Day4\\Controller_sfcn_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Controller_sid.h\r\n *\r\n * Trial License - for use to evaluate programs for possible purchase as\r\n * an end-user only.\r\n *\r\n * Code generation for model \"Controller_sf\".\r\n *\r\n * Model version              : 1.1\r\n * Simulink Coder version : 9.8 (R2022b) 13-May-2022\r\n * C source code generated on : Wed Aug 30 15:30:27 2023\r\n *\r\n * Target selection: rtwsfcn.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n *\r\n * SOURCES: Controller_sf.c\r\n */\r\n\r\n/* statically allocated instance data for model: Controller */\r\n{\r\n  {\r\n    /* Local SimStruct for the generated S-Function */\r\n    static LocalS slS;\r\n    LocalS *lS = &slS;\r\n    ssSetUserData(rts, lS);\r\n\r\n    /* block I/O */\r\n    {\r\n      static B_Controller_T sfcnB;\r\n      void *b = (real_T *) &sfcnB;\r\n      ssSetLocalBlockIO(rts, b);\r\n      (void) memset(b, 0,\r\n                    sizeof(B_Controller_T));\r\n    }\r\n\r\n    /* model checksums */\r\n    ssSetChecksumVal(rts, 0, 763650684U);\r\n    ssSetChecksumVal(rts, 1, 2512694527U);\r\n    ssSetChecksumVal(rts, 2, 3947079430U);\r\n    ssSetChecksumVal(rts, 3, 2370651937U);\r\n  }\r\n}\r\n"}],"trace":"","blocks":[{"RTWName":"<Root>/e","SIDString":"Controller:12"},{"RTWName":"<S1>/e","SIDString":"Controller:2"},{"RTWName":"<S2>/U","SIDString":"Controller:11:1"},{"RTWName":"<S2>/Data Type\nDuplicate","SIDString":"Controller:11:2"},{"RTWName":"<S2>/Diff","SIDString":"Controller:11:3"},{"RTWName":"<S2>/TSamp","SIDString":"Controller:11:4"},{"RTWName":"<S2>/UD","SIDString":"Controller:11:5"},{"RTWName":"<S2>/Y","SIDString":"Controller:11:6"},{"RTWName":"<S1>/Discrete-Time\nIntegrator","SIDString":"Controller:10"},{"RTWName":"<S1>/Gain","SIDString":"Controller:4"},{"RTWName":"<S1>/Gain1","SIDString":"Controller:5"},{"RTWName":"<S1>/Gain2","SIDString":"Controller:6"},{"RTWName":"<S1>/Sum1","SIDString":"Controller:8"},{"RTWName":"<S1>/Out1","SIDString":"Controller:9"},{"RTWName":"<Root>/Out1","SIDString":"Controller:13"},{"RTWName":"<Root>/Controller","SIDString":"Controller:1"},{"RTWName":"<S1>/Discrete Derivative","SIDString":"Controller:11"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};