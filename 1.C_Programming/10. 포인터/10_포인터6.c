// 10_포인터6.c
#include <stdio.h>
#if 0
int main(void)
{
    int x[2][3] = {
        /* p   ---> */ { 10, 20, 30 },
        /* p+1 ---> */ { 100, 200, 300 },
    };

    int(*p)[3];
    p = x;

    printf("%ld\n", (unsigned long)p);
    printf("%ld\n", (unsigned long)(p + 1));

    printf("%d\n", *(*(p + 1) + 2));
    printf("%d\n", *(p[1] + 2));

    printf("%d\n", p[1][2]);

    return 0;
}
#endif

// 포인터 산술 연산
// 1. 포인터 + 상수
//  : 포인터 + sizeof(대상체 타입) * 상수

// 2. 포인터 - 상수
#if 0
int main(void)
{
    //           p1        p2                  p3(마지막 요소 다음)
    //            |        |                    |
    int x[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    // int* p1 = &x[0]; // &*(x + 0)
    // int* p2 = &x[3]; // &*(x + 3)

    int* p1 = x;
    *p1 = 100;
    printf("%d\n", *p1);

    int* p2 = x + 3;
    *p2 = 100;
    printf("%d\n", *p2);

    int* p3 = x + 10; // 허용됩니다. Past the end
    *p3 = 100; /* 미정의 동작 */
    printf("%d\n", *p3); /* 미정의 동작 */
    // => 배열의 마지막 요소 다음을 포인터를 통해 가르키는 것(주소를 가지는 것)은
    // 허용되지만, 참조를 통해 값을 읽거나 변경하는 행위는 미정의 동작입니다.

    int* p4 = x + 11; // 허용 X, 참조하면 미정의 동작입니다.

    return 0;
}
#endif

// 포인터 - 상수
// : 포인터 주소 - sizeof(대상체 타입) * 상수

// 배열 또는 포인터를 통해 참조 연산 / 배열의 인덱스 연산을 사용할 경우
// 유효하지 않은(할당되지 않은) 메모리에 대한 참조 또는 연산은 미정의 동작입니다.
// => C언어는 컴파일 할 때, 아무것도 체크하지 않습니다.
//    C언어는 런타임에서도 아무것도 체크하지 않습니다.
#if 0
int main(void)
{
    //           p1        p2
    //            |        |
    int x[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    int* p1 = x;
    printf("%d\n", p1[2]); // 3
    printf("%d\n", p1[-1]); /* 미정의 동작 */

    int* p2 = x + 3;
    printf("%d\n", p2[2]); // 6

    printf("%d\n", *(p2 - 1)); // *(p2 - 1) ==> *(p2 + (-1))
    printf("%d\n", p2[-1]);

    return 0;
}
#endif

// * 포인터 + 포인터
// => 지원하지 않습니다.

// * 포인터 - 포인터
//  : 상대적 위치를 구하는 목적으로 사용합니다.
//   (포인터 주소값 - 포인터 주소값) / sizeof(대상체 타입 크기)

// 주의사항
//  : 같은 대상체의 메모리 영역안에서만 사용해야 합니다.

int main(void)
{
    //                 p2       p1
    //                  |        |
    double x[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    double* p1 = x + 5;
    double* p2 = x + 2;

    printf("%td\n", p1 - p2); //  3 => 3칸 뒤에 있다.
    printf("%td\n", p2 - p1); // -3 => 3칸 앞에 있다.

    double y[3];
    double* p3 = y + 1;

    printf("%td\n", p1 - p3); // 미정의 동작
    printf("%td\n", p3 - p1); // 미정의 동작

    return 0;
}